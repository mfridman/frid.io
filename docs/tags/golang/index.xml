<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on frid.io</title>
    <link>https://frid.io/tags/golang/</link>
    <description>Recent content in Golang on frid.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Feb 2018 17:36:50 -0500</lastBuildDate>
    
	<atom:link href="https://frid.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A mongoDB Go Driver - by the mongoDB folks</title>
      <link>https://frid.io/golang/a-new-mongodb-go-driver/</link>
      <pubDate>Thu, 22 Feb 2018 17:36:50 -0500</pubDate>
      
      <guid>https://frid.io/golang/a-new-mongodb-go-driver/</guid>
      <description>So this is exciting, the mongoDB team is working on an official mongoDB Go driver. The official announcement can be found at MongoDB Go Driver Alpha 1 released
For those interested why mongoDB chose to write a driver from the ground-up as apposed to forking mgo read their engineering blog
The repo can be found on github mongo-go-drive and bug reports should be filed over on jira.mongodb.org
I&amp;rsquo;ve been wanting to give mongoDB a fair shot, and now seems to be the right time.</description>
    </item>
    
    <item>
      <title>Shine on You Crazy Interface - #golang part1</title>
      <link>https://frid.io/golang/shine-on-you-crazy-interface/</link>
      <pubDate>Mon, 05 Feb 2018 20:07:41 -0500</pubDate>
      
      <guid>https://frid.io/golang/shine-on-you-crazy-interface/</guid>
      <description>Go&amp;rsquo;s interfaces are brilliant. It&amp;rsquo;s not immediately apparent and at first can be confusing, but after a while its brilliance shines through.
Simply understand that if a concrete type posses all necessary methods it, the concrete type, can implicitly satisfy an interface.
In Go, interfaces are considered abstract types, meaning we do not know what an interface really is, only what it can do.
The Go standard library makes use of interfaces, let&amp;rsquo;s take a look at an example.</description>
    </item>
    
    <item>
      <title>Shine on You Crazy Interface - #golang part2</title>
      <link>https://frid.io/golang/shine-on-you-crazy-interface2/</link>
      <pubDate>Mon, 05 Feb 2018 20:07:41 -0500</pubDate>
      
      <guid>https://frid.io/golang/shine-on-you-crazy-interface2/</guid>
      <description>No interface discussion is complete without talking about the fmt.Stringer interface. This is a classic when introducing the topic of interfaces.
Notice in part1 we actually made use of this interface to format the songs type.
func (s songs) String() string { var ss []string for i := range s { ss = append(ss, s[i].name+&#34; &#34;+fmt.Sprint(s[i].release.Year())) } return strings.Join(ss, &#34;, &#34;) }  When we called a print function the output was nicely formatted:</description>
    </item>
    
    <item>
      <title>Validating host keys in Go&#39;s ssh package</title>
      <link>https://frid.io/golang/go-ssh-hostkey/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/go-ssh-hostkey/</guid>
      <description>So you upgraded the package: go get -u -v golang.org/x/crypto/...
and got an error: ssh: must specify HostKeyCallback
A quick google search returns this great post Golang SSH Security, as well as issue#19767 and e4e2799.
Briefly, prior to the patch users could omit ssh.HostKeyCallback from ssh.ClientConfig, allowing SSH connections to bypass host key checking and &amp;ldquo;just work&amp;rdquo;.
Given the onus is on the client to verify the identity of the host, this was a step in the right direction in terms of security.</description>
    </item>
    
    <item>
      <title>Dealing with files in Go</title>
      <link>https://frid.io/golang/working-with-files/</link>
      <pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/working-with-files/</guid>
      <description>File existence Useful when you want to have consistency checking file existence, with a bit more granularity.
func exists(file string) (bool, error) { _, err := os.Stat(file) // stat success, file exists, exit early if err == nil { return true, nil } // check for an os.ErrNotExist, &#34;file does not exist&#34;. Return false and no errors. if os.IsNotExist(err) { return false, nil } // error from stat return false, err }  Used as follows:</description>
    </item>
    
  </channel>
</rss>