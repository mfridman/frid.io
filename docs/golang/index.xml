<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>frid.io</title>
    <link>https://frid.io/golang/</link>
    <description>Recent content on frid.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 Jul 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://frid.io/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Integrating Go modules with Drone CI</title>
      <link>https://frid.io/golang/go-modules-part3/</link>
      <pubDate>Sun, 29 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/go-modules-part3/</guid>
      <description>Go modules: part 1, part 2, part 3  coming soon&amp;hellip;
for now you can check out their site drone.io and blog
 Vendor is tailored for the dependencies of a specific module, not warming a cache. ðŸ¤” from issue#26610
 For CI/CD this may be useful, cl#126656
 and maybe issue#24250
  This section will be removed eventually Implementation deviations from the initial proposal and worthy highlights:</description>
    </item>
    
    <item>
      <title>Welcome, Go modules - part2</title>
      <link>https://frid.io/golang/go-modules-part2/</link>
      <pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/go-modules-part2/</guid>
      <description>Go modules: part 1, part 2, part 3   Go module
 GOPATH mode vs module-aware mode
 go.mod file
 Day-to-day commands
 upgrading
 downgrading
 excluding version
 remove exclusion
 replace
 dropping replacement
 updating and patching
 Advanced commands
   Go module A go module is a collection of related Go packages. A single unit that defines the minimum requirements that must be satisfied by their dependencies.</description>
    </item>
    
    <item>
      <title>Welcome, Go modules - part1</title>
      <link>https://frid.io/golang/go-modules-part1/</link>
      <pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/go-modules-part1/</guid>
      <description>Go modules: part 1, part 2, part 3  For those strictly interested in what is it and how do I use it? head over to part2.
I&amp;rsquo;ll skip majority of the historic bits and add a timeline for context. The path towards Go modules&amp;hellip;
  Makefiles pre-1.0  In the beginning, there were Makefiles such as these, scripts, maybe a ðŸ§™ and lots of 
          GOPATH 1.</description>
    </item>
    
    <item>
      <title>A mongoDB Go Driver - by the mongoDB folks</title>
      <link>https://frid.io/golang/a-new-mongodb-go-driver/</link>
      <pubDate>Thu, 22 Feb 2018 17:36:50 -0500</pubDate>
      
      <guid>https://frid.io/golang/a-new-mongodb-go-driver/</guid>
      <description>So this is exciting, the mongoDB team is working on an official mongoDB Go driver. The official announcement can be found at MongoDB Go Driver Alpha 1 released
For those interested why mongoDB chose to write a driver from the ground-up as apposed to forking mgo read their engineering blog
The repo can be found on github mongo-go-drive and bug reports should be filed over on jira.mongodb.org
I&amp;rsquo;ve been wanting to give mongoDB a fair shot, and now seems to be the right time.</description>
    </item>
    
    <item>
      <title>Shine on You Crazy Interface - part2</title>
      <link>https://frid.io/golang/shine-on-you-crazy-interface2/</link>
      <pubDate>Mon, 05 Feb 2018 20:07:41 -0500</pubDate>
      
      <guid>https://frid.io/golang/shine-on-you-crazy-interface2/</guid>
      <description>No interface discussion is complete without talking about the fmt.Stringer interface. This is a classic when introducing the topic of interfaces.
Notice in part1 we actually made use of this interface to format the songs type.
func (s songs) String() string { var ss []string for i := range s { ss = append(ss, s[i].name+&#34; &#34;+fmt.Sprint(s[i].release.Year())) } return strings.Join(ss, &#34;, &#34;) }  When we called a print function the output was nicely formatted:</description>
    </item>
    
    <item>
      <title>Shine on You Crazy Interface - part1</title>
      <link>https://frid.io/golang/shine-on-you-crazy-interface/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/shine-on-you-crazy-interface/</guid>
      <description>Go&amp;rsquo;s interfaces are brilliant. It&amp;rsquo;s not immediately apparent and at first can be confusing, but after a while its brilliance shines through.
Simply understand that if a concrete type posses all necessary methods it, the concrete type, can implicitly satisfy an interface.
In Go, interfaces are considered abstract types, meaning we do not know what an interface really is, only what it can do.
The Go standard library makes use of interfaces, let&amp;rsquo;s take a look at an example.</description>
    </item>
    
    <item>
      <title>To err, or not to err</title>
      <link>https://frid.io/golang/err-thoughts/</link>
      <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/err-thoughts/</guid>
      <description>Draft in progress..
Much of this will be based on Error handling in Upspin.
Not suitable for all projects, but interesting enough for further discussion and thought.</description>
    </item>
    
    <item>
      <title>Validating host keys in Go&#39;s ssh package</title>
      <link>https://frid.io/golang/go-ssh-hostkey/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/go-ssh-hostkey/</guid>
      <description>So you upgraded the package: go get -u -v golang.org/x/crypto/...
and got an error: ssh: must specify HostKeyCallback
A quick google search returns this great post Golang SSH Security, as well as issue#19767 and e4e2799.
Briefly, prior to the patch users could omit ssh.HostKeyCallback from ssh.ClientConfig, allowing SSH connections to bypass host key checking and &amp;ldquo;just work&amp;rdquo;.
Given the onus is on the client to verify the identity of the host, this was a step in the right direction in terms of security.</description>
    </item>
    
    <item>
      <title>Channel your inner communication, little goroutines</title>
      <link>https://frid.io/golang/goroutine-patterns/</link>
      <pubDate>Fri, 02 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/goroutine-patterns/</guid>
      <description>Below are some patterns and ideas I&amp;rsquo;ve come across wrt channels and goroutines. Just remember&amp;hellip;
...if you reach into your toolbox and decide to use goroutines always ask: how  and when  will those goroutines stop  This section will likely be split off into more specific posts in the future.
limit number of working goroutines with buffered channels Often times you don&amp;rsquo;t need thousands of goroutines working at once, especially true when communicating with external resources, e.</description>
    </item>
    
    <item>
      <title>Dealing with files in Go</title>
      <link>https://frid.io/golang/working-with-files/</link>
      <pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://frid.io/golang/working-with-files/</guid>
      <description>File existence Useful when you want to have consistency checking file existence, with a bit more granularity.
func exists(file string) (bool, error) { _, err := os.Stat(file) // stat success, file exists, exit early if err == nil { return true, nil } // check for an os.ErrNotExist, &#34;file does not exist&#34;. Return false and no errors. if os.IsNotExist(err) { return false, nil } // error from stat return false, err }  Used as follows:</description>
    </item>
    
  </channel>
</rss>